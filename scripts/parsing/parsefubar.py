import re, sys, csv
from numpy import *
from Bio import AlignIO, SeqIO
from parsing_fxns import *

if len(sys.argv) != 2:
	print "Usage: python parsefubar.py <dataset>    , where dataset is HA or GP41"
	sys.exit(0)

# Weighted algorithms
walgs=['BMweights', 'PDweights', 'BMweightsP', 'PDweightsP']
# Guidance algorithms
galgs=['Guidance', 'GuidanceP']
genes=['or5', 'rho', 'prk', 'flat']
pp_cutoff = 0.895 # Posterior probability threshold for calling sites as positively selected or not.
gridSize = 100 # dimensionality for FUBAR grid

datadir='/Users/sjspielman/Dropbox/aln/results/'
dataset = sys.argv[1]
assert (dataset == 'HA' or dataset == 'GP41'), "Must specify either HA or GP41 as the dataset."
if dataset == 'GP41':
	datadir += 'GP41/'
	posStart = 10
	masks = {'50':'fifty'}
elif dataset == 'HA':
	datadir += 'HA/'
	posStart = 18
	masks={'30': 'thirty', '50':'fifty', '70':'seventy', '90':'ninety'} #masking analysis only done w/ this dataset.


outfile='/Users/sjspielman/Research/alignment_filtering/data/parsed_data/revision/fubar_'+dataset+'_90.txt'
outhandle=open(outfile, 'w')
outhandle.write('count\ttprate\tfprate\tfnrate\taccuracy\tcase\tgene\tmask\tmethod\tpenal\tnum_masked\tave_masked\tperc_masked\tprior\tomega\n')


for gene in genes:

	print gene+'\n'
	
	############ Set up gene-specific data directories ############
	
	# Directories: fubar output, paml output, alignments (all made with linsi, except for true alignments as generated by Indelible)
	fudir   = datadir+'fubar/fubar_'+gene+'/'
	alndir  = datadir+'alntree/aaguided_'+gene+'/'
	
	# Directories: true simulated alignments and evolutionary rate categories
	truerates_dir=datadir+'Simulation/truerates/'+gene+'/'
	truealn_dir=datadir+'Simulation/sequences/'+gene+'/'
	
			
	for n in range(100):
		print str(n)
		
		## File names (refaln, truealn, truerates)
		refaln=alndir+'refaln'+str(n)+'.fasta'
		trfile=truerates_dir+'truerates'+str(n)+'.txt'
		truealn=truealn_dir+'truealn_aa'+str(n)+'.fasta'
		
		
		## Read in the reference alignment and collect some relevant info
		handle = open(refaln, 'r')
		refparsed=AlignIO.read(refaln, 'fasta')
		handle.close()
		alnlen=len(refparsed[0])
		numseq=len(refparsed)
		
		## Read in the true alignment
		handle = open(truealn, 'r')
		trueparsed=AlignIO.read(handle, 'fasta')
		handle.close()
		true_alnlen = len(trueparsed[0])
		
		###########################################################################################################
		#################### Assess accuracy for the true alignment before anything else ##########################
			
		# In this case, our reference alignment is actually the true alignment.
		# We are using the same mapping strategy for the true state as below because otherwise the tprate measures are DEFLATED due to gappiness in the true alignment. Only by using the same mapping strategy can we have a fair comparison among all results.
		wantRef, wantTrue = singleTaxonMap(trueparsed, trueparsed, numseq, true_alnlen)	
		truepos = parseTrueRates(trfile, wantTrue, posStart)
	
		fubar = fudir+'fubar/truealn'+str(n)+'.fasta.fubar'	
		
		testprobs = parseFUBAR(wantRef, fubar)	
		assert(len(truepos)==len(testprobs)), "True FUBAR Mapping has failed."
		(tp,tn,fp,fn,tprate,fprate,tnrate,fnrate,accuracy) = getAccuracy(pp_cutoff, truepos, testprobs)
		outhandle.write(str(n)+'\t'+str(tprate)+'\t'+str(fprate)+'\t'+str(fnrate)+'\t'+str(accuracy)+'\ttruealn\t'+gene+'\ttrue\tfubar\ttrue\t0\t0\t0\t0\t0\n')	
		###########################################################################################################

		###########################################################################################################
		################## Assess accuracy for the refaln. Comes first since it isn't masked.  ####################
		
		
		# Note that these values will be used for all subsequent alignments in this n rep. 
		# wantRef = sites we want from reference. wantTrue = sites we want from true. Note that we are only now using the singletaxonmap!
		wantRef, wantTrue = singleTaxonMap(trueparsed, refparsed, numseq, alnlen)	
		truepos = parseTrueRates(trfile, wantTrue, posStart)
		
		name = 'refaln'+str(n)+'.fasta'
		fubar = fudir+'fubar/'+name+'.fubar'	
		testprobs = parseFUBAR(wantRef, fubar)	
		assert(len(truepos)==len(testprobs)), "Reference FUBAR Mapping has failed."
		
		# Grab info on priors
		prior, omega = getFUBARprior(fudir, name, gridSize)
		
		(tp,tn,fp,fn,tprate,fprate,tnrate,fnrate,accuracy) = getAccuracy(pp_cutoff, truepos, testprobs)
		outhandle.write(str(n)+'\t'+str(tprate)+'\t'+str(fprate)+'\t'+str(fnrate)+'\t'+str(accuracy)+'\trefaln\t'+gene+'\tzero\tfubar\tzero\t0\t0\t0\t'+str(prior)+'\t'+str(omega)+'\n')	
		###########################################################################################################

		
		###########################################################################################################		
		########################## Assess accuracy for Guidance(P), which use all masks ###########################
		for mask in masks:
			for alg in galgs:
				
				# Penalization algorithm or not? (for printing to outfile)
				if alg=='Guidance':
					penal='no'				
				else:
					penal='yes'
					
				# Get alignment and fubar files for this algorithm
				name = alg+'_'+mask+'_'+str(n)+'.fasta'
				
				# Get masking information relevant to this case
				(num, ave, perc) = assessMasking(alndir+name)
			
				# Get accuracy information relevant to this case
				fubar=fudir+'fubar/'+name+'.fubar' 
				testprobs = parseFUBAR(wantRef, fubar)	
				assert(len(truepos)==len(testprobs)), "FUBAR Mapping has failed."
	
				# Grab info on priors, only for 50 masking
				if mask == '50':
					prior, omega = getFUBARprior(fudir, name, gridSize)
				else:
					prior = 0
					omega = 0
		
				## FUBAR assessment	at single posterior probability cutoff			
				(tp,tn,fp,fn,tprate,fprate,tnrate,fnrate,accuracy)=getAccuracy(pp_cutoff, truepos, testprobs)
				outhandle.write(str(n)+'\t'+str(tprate)+'\t'+str(fprate)+'\t'+str(fnrate)+'\t'+str(accuracy)+'\t'+alg+'\t'+gene+'\t'+masks[mask]+'\tfubar\t'+penal+'\t'+str(num)+'\t'+str(ave)+'\t'+str(perc)+'\t'+str(prior)+'\t'+str(omega)+'\n')
				
		###########################################################################################################		
		####################### Assess accuracy for BM/PDweights(P), which use only mask 0.5 ######################
		for alg in walgs:		
			# Penalization algorithm or not? (for printing to outfile)
			if alg=='BMweights' or alg=='PDweights':
				penal='no'				
			else:
				penal='yes'
				
			# Collect alignment and fubar files for this algorithm
			name = alg+'_50_'+str(n)+'.fasta'
			
			# Get masking information relevant to this case
			(num, ave, perc) = assessMasking(alndir+name)
			
			# Get information relevant to this case
			fubar=fudir+'fubar/'+name+'.fubar' 
			testprobs = parseFUBAR(wantRef, fubar)	
			assert( len(truepos)==len(testprobs)), "FUBAR Mapping has failed."
	
			# Grab info on priors
			prior, omega = getFUBARprior(fudir, name, gridSize)
				
			## FUBAR assessment	at single posterior probability cutoff			
			(tp,tn,fp,fn,tprate,fprate,tnrate,fnrate,accuracy)=getAccuracy(pp_cutoff, truepos, testprobs)
			outhandle.write(str(n)+'\t'+str(tprate)+'\t'+str(fprate)+'\t'+str(fnrate)+'\t'+str(accuracy)+'\t'+alg+'\t'+gene+'\tfifty\tfubar\t'+penal+'\t'+str(num)+'\t'+str(ave)+'\t'+str(perc)+'\t'+str(prior)+'\t'+str(omega)+'\n')		
outhandle.close()

			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		
				
			
			
			
			
			
			