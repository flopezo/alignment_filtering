import re, sys, csv
from numpy import *
from Bio import AlignIO, SeqIO
from parsing_fxns import *

# Weighted algorithms
walgs=['BMweights', 'PDweights', 'BMweightsP', 'PDweightsP']
# Guidance algorithms
galgs=['Guidance', 'GuidanceP']
masks={'30': 'thirty', '50':'fifty', '70':'seventy', '90':'ninety'}
genes=['or5', 'rho', 'prk', 'flat']
pp_cutoff = 0.895 # Posterior probability threshold for calling sites as positively selected or not.
gridSize = 100 # dimensionality for FUBAR grid
datadir='/Users/sjspielman/Dropbox/aln/results/'
dataset = sys.argv[1]
assert (dataset == 'HA' or dataset == 'GP41'), "Must specify either HA or GP41 as the dataset."
if dataset == 'GP41':
	datadir += 'GP41/'
	posStart = 10
elif dataset == 'HA':
	datadir += 'HA/'
	posStart = 18
maptype = sys.argv[2]
assert (maptype == 'singletaxonmap' or maptype == 'consensusmap'), "Must specify either taxon or consensus map strategy."

#outfile = '/Users/sjspielman/Desktop/TEST.txt'
outfile='/Users/sjspielman/Research/alignment_filtering/data/parsed_data/'+maptype+'/fubar_'+dataset+'_90_NEW.txt'
outhandle=open(outfile, 'w')
outhandle.write('count\ttprate\tfprate\t\tfnrate\taccuracy\tcase\tgene\tmask\tmethod\tpenal\tnum_masked\tave_masked\tperc_masked\tprior\tomega\n')


for gene in genes:

	print gene+'\n'
	
	############ Set up gene-specific data directories ############
	
	# Directories: fubar output, paml output, alignments (all made with linsi, except for true alignments as generated by Indelible)
	fudir   = datadir+'fubar/fubar_'+gene+'/'
	alndir  = datadir+'alntree/aaguided_'+gene+'/'
	
	# Directories: true simulated alignments and evolutionary rate categories
	truerates_dir=datadir+'Simulation/truerates/'+gene+'/'
	truealn_dir=datadir+'Simulation/sequences/'+gene+'/'
	
			
	for n in range(100):
		print str(n)
		
		## File names (refaln, truealn, truerates)
		refaln=alndir+'refaln'+str(n)+'.fasta'
		trfile=truerates_dir+'truerates'+str(n)+'.txt'
		truealn=truealn_dir+'truealn_aa'+str(n)+'.fasta'
		
		
		## Read in the reference alignment and collect some relevant info
		handle = open(refaln, 'r')
		refparsed=AlignIO.read(refaln, 'fasta')
		handle.close()
		alnlen=len(refparsed[0])
		numseq=len(refparsed)
		
		## Read in the true alignment
		handle = open(truealn, 'r')
		trueparsed=AlignIO.read(handle, 'fasta')
		handle.close()
		true_alnlen = len(trueparsed[0])
		
		###########################################################################################################
		#################### Assess accuracy for the true alignment before anything else ##########################
	
		fubar = fudir+'fubar/truealn'+str(n)+'.fasta.fubar'	
		
		(truepos, testprobs) = assessTrueFUBAR(trfile, fubar, posStart)
		assert(len(truepos)==len(testprobs)), "True FUBAR Mapping has failed."
		(tp,tn,fp,fn,tprate,fprate,tnrate,fnrate,accuracy) = getAccuracy(pp_cutoff, truepos, testprobs)
		outhandle.write(str(n)+'\t'+str(tprate)+'\t'+str(fprate)+'\t'+str(fnrate)+'\t'+str(accuracy)+'\ttruealn\t'+gene+'\ttrue\tfubar\ttrue\t0\t0\t0\t0\n')	
		###########################################################################################################

		###########################################################################################################
		################## Assess accuracy for the refaln. Comes first since it isn't masked.  ####################
		
		
		# Note that these values will be used for all subsequent alignments in this n rep.
		# wantRef = sites we want from reference. wantTrue = sites we want from true. Note the alternative mapping strategies.	
		if maptype == 'singletaxonmap':		
			wantRef, wantTrue = singleTaxonMap(trueparsed, refparsed, numseq, alnlen)	
		else:
			wantRef, wantTrue = consensusMap(trueparsed, refparsed, numseq, alnlen)
		
		truepos = parseTrueRates(trfile, wantTrue, posStart)
		
		name = 'refaln'+str(n)+'.fasta'
		fubar = fudir+'fubar/'+name+'.fubar'	
		testprobs = parseFUBAR(wantRef, fubar)	
		assert(len(truepos)==len(testprobs)), "Reference FUBAR Mapping has failed."
		
		# Grab info on priors
		prior, omega = getFUBARprior(fudir, name, gridSize)
		
		(tp,tn,fp,fn,tprate,fprate,tnrate,fnrate,accuracy) = getAccuracy(pp_cutoff, truepos, testprobs)
		outhandle.write(str(n)+'\t'+str(tprate)+'\t'+str(fprate)+'\t'+str(fnrate)+'\t'+str(accuracy)+'\trefaln\t'+gene+'\tzero\tfubar\tzero\t0\t0\t0\t'+str(prior)+'\t'+str(omega)+'\n')	
		###########################################################################################################

		
		###########################################################################################################		
		########################## Assess accuracy for Guidance(P), which use all masks ###########################
		for mask in masks:
			for alg in galgs:
				
				# Penalization algorithm or not? (for printing to outfile)
				if alg=='Guidance':
					penal='no'				
				else:
					penal='yes'
					
				# Get alignment and fubar files for this algorithm
				name = alg+'_'+mask+'_'+str(n)+'.fasta'
				
				# Get masking information relevant to this case
				(num, ave, perc) = assessMasking(alndir+name)
			
				# Get accuracy information relevant to this case
				fubar=fudir+'fubar/'+name+'.fubar' 
				testprobs = parseFUBAR(wantRef, fubar)	
				assert(len(truepos)==len(testprobs)), "FUBAR Mapping has failed."
	
				# Grab info on priors, only for 50 masking
				if mask == '50':
					prior, omega = getFUBARprior(fudir, name, gridSize)
				else:
					prior = 0
					omega = 0
		
				## FUBAR assessment	at single posterior probability cutoff			
				(tp,tn,fp,fn,tprate,fprate,tnrate,fnrate,accuracy)=getAccuracy(pp_cutoff, truepos, testprobs)
				outhandle.write(str(n)+'\t'+str(tprate)+'\t'+str(fprate)+'\t'+str(fnrate)+'\t'+str(accuracy)+'\t'+alg+'\t'+gene+'\t'+masks[mask]+'\tfubar\t'+penal+'\t'+str(num)+'\t'+str(ave)+'\t'+str(perc)+'\t'+str(prior)+'\t'+str(omega)+'\n')
				
		###########################################################################################################		
		####################### Assess accuracy for BM/PDweights(P), which use only mask 0.5 ######################
		for alg in walgs:		
			# Penalization algorithm or not? (for printing to outfile)
			if alg=='BMweights' or alg=='PDweights':
				penal='no'				
			else:
				penal='yes'
				
			# Collect alignment and fubar files for this algorithm
			name = alg+'_50_'+str(n)+'.fasta'
			
			# Get masking information relevant to this case
			(num, ave, perc) = assessMasking(alndir+name)
			
			# Get information relevant to this case
			fubar=fudir+'fubar/'+name+'.fubar' 
			testprobs = parseFUBAR(wantRef, fubar)	
			assert( len(truepos)==len(testprobs)), "FUBAR Mapping has failed."
	
			# Grab info on priors
			prior, omega = getFUBARprior(fudir, name, gridSize)
				
			## FUBAR assessment	at single posterior probability cutoff			
			(tp,tn,fp,fn,tprate,fprate,tnrate,fnrate,accuracy)=getAccuracy(pp_cutoff, truepos, testprobs)
			outhandle.write(str(n)+'\t'+str(tprate)+'\t'+str(fprate)+'\t'+str(fnrate)+'\t'+str(accuracy)+'\t'+alg+'\t'+gene+'\tfifty\tfubar\t'+penal+'\t'+str(num)+'\t'+str(ave)+'\t'+str(perc)+'\t'+str(prior)+'\t'+str(omega)+'\n')		
outhandle.close()

			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		
				
			
			
			
			
			
			